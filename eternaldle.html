<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eternaldle</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/style.css">
</head>
<body class="flex flex-col items-center min-h-screen p-4">

    <div class="w-full max-w-4xl mx-auto">
        <h1 class="text-4xl font-bold text-center mb-2 site-title">Eternaldle</h1>
        <p class="text-center text-gray-400 mb-6">Adivinhe o personagem de hoje!</p>
        
        <div id="game-container" class="mb-6">
            <div class="flex flex-col sm:flex-row gap-2">
                <input type="text" id="characterInput" list="characterList" placeholder="Digite o nome de um personagem..." class="flex-grow p-3 rounded-md text-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                <datalist id="characterList"></datalist>
                <button id="guessButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-md text-lg transition-colors">Adivinhar</button>
            </div>
        </div>

        <div id="win-message-container" class="text-center hidden"></div>

        <div class="overflow-x-auto rounded-lg shadow-md">
            <table class="w-full text-sm text-left">
                <thead class="bg-[#2c2c31] text-xs uppercase">
                    <tr>
                        <th scope="col" class="px-4 py-3">Personagem</th>
                        <th scope="col" class="px-4 py-3">Gênero</th>
                        <th scope="col" class="px-4 py-3">Classe</th>
                        <th scope="col" class="px-4 py-3">Alcance</th>
                        <th scope="col" class="px-4 py-3">Cabelo</th>
                        <th scope="col" class="px-4 py-3">Lançamento</th>
                        <th scope="col" class="px-4 py-3">Armas</th>
                    </tr>
                </thead>
                <tbody id="results-body">
                    <!-- As linhas de resultado serão inseridas aqui -->
                </tbody>
            </table>
        </div>
    </div>

    <div id="toast" class="toast"></div>

    <script>
        const characterInput = document.getElementById('characterInput');
        const guessButton = document.getElementById('guessButton');
        const resultsBody = document.getElementById('results-body');
        const characterList = document.getElementById('characterList');
        const winMessageContainer = document.getElementById('win-message-container');
        const gameContainer = document.getElementById('game-container');
        
        let characterNames = [];
        let isGameOver = false;

        // LocalStorage helpers to persist guesses per-solution (by date)
        const todayKey = () => `eternaldle_guesses_${new Date().toISOString().slice(0,10)}`;
        const wonKey = () => `eternaldle_won_${new Date().toISOString().slice(0,10)}`;

        function loadLocalGuesses() {
            try {
                const raw = localStorage.getItem(todayKey());
                return raw ? JSON.parse(raw) : [];
            } catch (e) { return []; }
        }
        function saveLocalGuesses(guesses) {
            try { localStorage.setItem(todayKey(), JSON.stringify(guesses)); } catch (e) { /* ignore */ }
        }
        function setLocalWon(flag) {
            try { localStorage.setItem(wonKey(), flag ? '1' : ''); } catch (e) {}
        }
        function getLocalWon() {
            try { return !!localStorage.getItem(wonKey()); } catch (e) { return false; }
        }

        function showToast(message, isError = false) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast show';
            toast.classList.add(isError ? 'error' : 'success');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        async function startGame() {
            try {
                // A chamada fetch usa um caminho relativo, que é a forma mais robusta.
                // Se isto falhar, o erro será capturado e exibido na consola.
                const response = await fetch('/api/start_game', {
                    method: 'POST',
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Resposta inválida do servidor.' }));
                    throw new Error(errorData.error || `Erro do Servidor: ${response.status}`);
                }

                const data = await response.json();
                characterNames = data.characterNames.map(name => name.trim());
                // Do not populate the datalist immediately — populate when user types >=2 chars
                characterList.innerHTML = '';

                // Restore persisted guesses for this session/day
                const localGuesses = loadLocalGuesses();
                if (localGuesses && localGuesses.length > 0) {
                    localGuesses.forEach(g => {
                        try { renderResults(g.results); } catch (e) { console.error('Failed to render a local previous guess', e); }
                    });
                } else if (data.previousGuesses && data.previousGuesses.length > 0) {
                    // If server has session guesses but local doesn't, adopt server-side guesses into local
                    data.previousGuesses.forEach(g => {
                        try { renderResults(g.results); } catch (e) { console.error('Failed to render a previous guess', e); }
                    });
                    try { saveLocalGuesses(data.previousGuesses); } catch (e) {}
                }

                // If the session already won for today, show win state
                const localWon = getLocalWon();
                if (data.hasWon || localWon) {
                    isGameOver = true;
                    gameContainer.classList.add('hidden');
                    let countText = '';
                    if (typeof data.todayCorrectCount !== 'undefined') {
                        const n = data.todayCorrectCount;
                        countText = `<p class="mt-2 text-gray-300">${n} ${n === 1 ? 'pessoa acertou' : 'pessoas acertaram'} o personagem de hoje.</p>`;
                    }
                    winMessageContainer.innerHTML = `<h2 class="text-3xl font-bold text-green-400 win-message">Parabéns! Você acertou!</h2>${countText}`;
                    winMessageContainer.classList.remove('hidden');
                }

            } catch (error) {
                console.error("ERRO DETALHADO AO INICIAR O JOGO (fetch):", error);
                showToast('Falha grave ao comunicar com o servidor. Verifique a consola (F12).', true);
            }
        }

        async function handleGuess() {
            const guess = characterInput.value.trim();
            if (isGameOver || !guess) return;
            
            if (!characterNames.some(name => name.toLowerCase() === guess.toLowerCase())) {
                showToast("Nome de personagem inválido", true);
                return;
            }

            try {
                const response = await fetch('/api/guess', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ guess: guess })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Resposta inválida do servidor.' }));
                    throw new Error(errorData.error || `Erro do Servidor: ${response.status}`);
                }
                
                const data = await response.json();
                renderResults(data.results);

                if (data.isCorrect) {
                    isGameOver = true;
                    gameContainer.classList.add('hidden');
                    let countText = '';
                    if (typeof data.todayCorrectCount !== 'undefined') {
                        const n = data.todayCorrectCount;
                        countText = `<p class="mt-2 text-gray-300">${n} ${n === 1 ? 'pessoa acertou' : 'pessoas acertaram'} o personagem de hoje.</p>`;
                    }
                    winMessageContainer.innerHTML = `<h2 class="text-3xl font-bold text-green-400 win-message">Parabéns! Você acertou!</h2>${countText}`;
                    winMessageContainer.classList.remove('hidden');
                    showToast('Você venceu!', false);
                    // Mark local won flag
                    setLocalWon(true);
                }

                // Persist this guess locally so it survives F5 (avoid duplicates)
                try {
                    const lsKey = todayKey();
                    const existing = loadLocalGuesses();
                    const entry = { guess: guess, results: data.results, isCorrect: data.isCorrect };
                    if (!existing.some(g => g.guess.toLowerCase() === guess.toLowerCase())) {
                        existing.push(entry);
                        saveLocalGuesses(existing);
                    }
                } catch (e) { console.error('Could not persist guess locally', e); }

                characterInput.value = '';
            
            } catch (error) {
                console.error("ERRO DETALHADO AO FAZER PALPITE (fetch):", error);
                showToast('Falha ao comunicar com o servidor. Verifique a consola (F12).', true);
            }
        }

        function renderResults(results) {
            const row = document.createElement('tr');
            row.classList.add('bg-[#212124]', 'border-b', 'border-gray-700');

            const statusToClass = {
                correct: 'correct-bg',
                partial: 'partial-bg',
                incorrect: 'incorrect-bg',
                higher: 'higher-bg',
                lower: 'lower-bg'
            };

            const createCell = (content, status) => {
                const cell = document.createElement('td');
                cell.className = `px-4 py-2 font-medium whitespace-nowrap text-white ${statusToClass[status] || ''}`;
                cell.innerHTML = content;
                return cell;
            };

            const characterCell = document.createElement('td');
            characterCell.className = `px-4 py-2 font-medium whitespace-nowrap text-white ${statusToClass[results.nome.status]}`;
            const img = document.createElement('img');
            img.src = results.imagem_url.value;
            img.alt = results.nome.value;
            img.className = 'character-image inline-block mr-3';
            img.crossOrigin = "anonymous"; // Importante para CORS
            img.onerror = () => { 
                console.error("Falha ao carregar imagem:", results.imagem_url.value);
                img.alt = "Falha";
            };
            characterCell.appendChild(img);
            characterCell.append(results.nome.value);
            
            row.appendChild(characterCell);
            row.appendChild(createCell(results.genero.value, results.genero.status));
            row.appendChild(createCell(results.classe.value, results.classe.status));
            row.appendChild(createCell(results.alcance.value, results.alcance.status));
            row.appendChild(createCell(results.cor_cabelo.value, results.cor_cabelo.status));
            
            let launchContent = results.ano_de_lancamento.value;
            if(results.ano_de_lancamento.status === 'higher') launchContent += ' ↓'; // Corrigido
            if(results.ano_de_lancamento.status === 'lower') launchContent += ' ↑'; // Corrigido
            row.appendChild(createCell(launchContent, results.ano_de_lancamento.status));

            let weaponContent = results.quantidade_de_arma.value;
            if(results.quantidade_de_arma.status === 'higher') weaponContent += ' ↓'; // Corrigido
            if(results.quantidade_de_arma.status === 'lower') weaponContent += ' ↑'; // Corrigido
            row.appendChild(createCell(weaponContent, results.quantidade_de_arma.status));

            resultsBody.prepend(row);
        }

        document.addEventListener('DOMContentLoaded', startGame);
        // Update datalist only after user types 2+ characters
        characterInput.addEventListener('input', () => {
            const val = characterInput.value.trim();
            if (val.length >= 2 && characterNames && characterNames.length > 0) {
                const q = val.toLowerCase();
                // Use case-insensitive partial match and limit number of options
                const matches = characterNames.filter(name => name.toLowerCase().includes(q)).slice(0, 50);
                characterList.innerHTML = matches.map(name => `<option value="${name}"></option>`).join('');
            } else {
                characterList.innerHTML = '';
            }
        });
        guessButton.addEventListener('click', handleGuess);
        characterInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleGuess();
            }
        });
    </script>
</body>
</html>

